from typemap import TypeMapHandler


class HLSLCodeGenerator:

    def __init__(self, typemapDict: dict, grammar: dict, outputFilepath: str, verbose=False) -> None:
        self.verbose = verbose
        self.grammar = grammar
        self.typemap = TypeMapHandler(grammar, typemapDict, verbose)
        self.outFilepath = outputFilepath
        self.out = open(outputFilepath, "w")

    def GetHeaderGuard(self) -> str:
        """
        Returns header guard from output filepath
        """
        filepath = self.outFilepath
        headerGuard = "_"
        charsSinceUnderscore = 0
        skipNonAlpha = True  # by skipping non aplha characters, we can trim non alphabethic or numeric chars at the start
        for charIndex in range(0, len(filepath)):
            char: str = filepath[charIndex]
            if char.isalpha() or char.isnumeric():
                skipNonAlpha = False
                if char.isupper() and charsSinceUnderscore > 2:  # insert underscores before upper case letters
                    headerGuard = headerGuard + "_" + char
                    charsSinceUnderscore = 1
                else:
                    headerGuard = headerGuard + char.upper()
                    charsSinceUnderscore += 1
            else:
                if not skipNonAlpha:
                    headerGuard += "_"
                    charsSinceUnderscore = 0
                skipNonAlpha = True
                continue

        headerGuard += "_INCLUDED_"
        if self.verbose:
            print(f"Header guard for file {filepath} is '{headerGuard}'")
        return headerGuard

    def WriteHeader(self):
        """
        This function writes a information about copyright, header guard defines, and namespace delcarations
        Nabla includes are hardcoded for now
        """
        if self.verbose:
            print("Writing header")
        header_guard = self.GetHeaderGuard()
        header = f"""
// Copyright (C) 2024 - DevSH Graphics Programming Sp. z O.O.
// This autogenerated file is part of the "Nabla Engine".
// This file was created using Spirv HLSL intrinsics generator
// For conditions of distribution and use, see copyright notice in nabla.h


#ifndef {header_guard}
#define {header_guard}


#ifdef __HLSL_VERSION
#include "spirv/unified1/spirv.hpp"
#include "spirv/unified1/GLSL.std.450.h"
#endif

""" + """
namespace nbl
{
namespace hlsl
{
#ifdef __HLSL_VERSION
namespace spirv
{
"""
        self.out.write(header)

    def WriteFooter(self):
        if self.verbose:
            print("Writing footer")
        footer = """

}
#endif
}
}

#endif

"""
        self.out.write(footer)

    def WriteBuiltin(self, input: dict):

        # validate input
        if not "name" in input.keys():
            raise ValueError("No 'name' field in builtin, check input json file.")

        variableName: str = input['name']
        builtinName = "BuiltIn"+variableName
        isConst = input.get('const', True)
        typeName = input.get('type', self.typemap.defaultType)
        if self.verbose:
            print(f"\tWriting built-in variable: name of built-in var: {builtinName}, name of var: {variableName}, is const: {isConst}, type: {typeName}")
        # potentially look up the 'variableName' in grammar['operand_kinds'] and check if field ['enumerant'] matches, then print capablities as comments
        self.out.write(f"[[vk::ext_builtin_input(spv::{builtinName})]]\n")
        self.out.write(f"static {'const ' if isConst else ''}{typeName} {variableName};\n")

    def WriteBuiltins(self, input: dict):
        listOfBuiltinsToExpose = input.get('builtins', [])
        if self.verbose:
            print(f"Beginning to write {len(listOfBuiltinsToExpose)} builtins")
        if len(listOfBuiltinsToExpose) > 0:
            self.out.write("// Built-ins\n\n")

        for builtinInfo in listOfBuiltinsToExpose:
            self.WriteBuiltin(builtinInfo)
            self.out.write('\n')

    def WriteInstruction(self, instruction: dict):
        """
        Generates code for a single spirv instruction and writes it to file output
        """
        opname: str = instruction['opname']
        if self.verbose:
            print(f"\t\tWriting instruction '{opname}'")
        toWrite = f'// {opname}\n'
        templateParams = self.typemap.GetGenericTypeList(instruction)
        if len(templateParams) > 0:
            templateDecl = f"template<{', '.join('typename '+ t for t in templateParams)}>\n"
            toWrite += templateDecl
        attributeDecl = f"[[vk::ext_instruction(spv::{opname})]]\n"
        toWrite += attributeDecl
        if any(op['kind'] == 'IdResult' for op in instruction['operands']):
            returnTypeMapping = self.typemap.GetReturnTypeMapping(opname)
            if returnTypeMapping is None:
                if self.verbose:
                    print(f"\t\t\tReturn type mapping is None for '{opname}', falling back to using default type")
                toWrite += self.typemap.defaultType

            else:
                if returnTypeMapping.const:
                    toWrite += "const "
                toWrite += returnTypeMapping.typeName
        else:
            toWrite += "void"
        functionName = opname[2:] if opname.startswith("Op") else opname
        params = self.typemap.GetFunctionParameters(instruction)
        toWrite += f" {functionName}({', '.join(params)});\n"
        self.out.write(toWrite)

    def WriteInstructionClass(self, classInfo):
        """
        Exposes code for all instructions present in the grammar file that 
        belong to the class defined in 'classInfo['class']' 
        and are listed in 'classInfo['operandList']'

        if operandList contains wildcard char "*" all operands from the class will be exposed
        """
        allInstructions = self.grammar['instructions']
        expoedInstructions = set()
        if 'class' not in classInfo.keys():
            raise ValueError("In the input file with list of classes and instructions to expose, there is an entry without class name.")

        if 'operandList' not in classInfo.keys():
            raise ValueError("In thei nput file with list of classes and instructions to expose, there is an entry without a list of instructions. Consider using * to write all instructions from this class")

        className = classInfo['class']
        operandList = classInfo['operandList']
        skipContainsCheck = "*" in operandList
        exposedAnything = False
        if self.verbose:
            print(f"\tBeginning writing class of operands '{className}'")

        for instruction in allInstructions:
            if instruction['class'] == className:
                if skipContainsCheck or instruction['opname'] in operandList:
                    if not exposedAnything:
                        # first time writing anything about this class, print a comment in the output file indicating start of class
                        if self.verbose:
                            print(f"\tAdding header for class '{className}'")
                        exposedAnything = True
                        self.out.write(f"// Class '{className}'\n")
                    self.WriteInstruction(instruction)
                    expoedInstructions.add(instruction['opname'])
                    self.out.write(("\n"))
        if self.verbose:
            missing = [op for op in operandList if op not in expoedInstructions]
            for missingOp in missing:
                if missingOp != '*':
                    print(f"Not emitting instruction {missingOp} as it is not present in the current grammar file")

    def WriteInstructions(self, input: dict):
        if self.verbose:
            print("Beginning writing operands")
        for classInfo in input.get('operand', []):
            self.WriteInstructionClass(classInfo)

    def WriteAll(self, input: dict):
        """
        Writes the complete hlsl file
        """
        self.WriteHeader()
        self.WriteBuiltins(input)
        self.out.write("\n\n")
        self.WriteInstructions(input)
        self.WriteFooter()
        if self.verbose:
            print("Done")
